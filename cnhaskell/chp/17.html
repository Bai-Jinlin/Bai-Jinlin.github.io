

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>第 17 章：面向 C 语言的接口：FFI &#8212; Real World Haskell 中文版</title>
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="第 18 章： Monad变换器" href="18.html" />
    <link rel="prev" title="第 16 章：使用Parsec" href="16.html" /> 
  </head><body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="16.html">第 16 章：使用Parsec</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="18.html">第 18 章： Monad变换器</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="c-ffi">
<h1>第 17 章：面向 C 语言的接口：FFI<a class="headerlink" href="#c-ffi" title="Permalink to this headline">¶</a></h1>
<p>编程语言间并不存在完美的隔离。
他们充斥在经过数十年时间所建立的工具和库组成的生态系统中, 通常由各种编程语言所编写。
好的工程实践建议我们去复用这些成果。Haskell 外部函数接口（以下简称FFI）是让 Haskell 代码使用其他语言或被其他语言使用的一种方法。
在本章中，我们将了解FFI是如何工作的，以及如何去生成 Haskell 对于 C 库的绑定，包括如何使用 FFI 预处理器自动完成大部分工作。
本章我们的挑战是：使用标准的 Perl 兼容的正则表达式库 PCRE 并且让这这个库在 Haskell 中以高效和函数式的方式被使用。在整个过程中, 我们将寻求一种抽象出 C 语言实现所需的手动工作, 将工作代理给 Haskell 使接口更加健壮, 产生整洁又高层次的绑定。在这里我们假设你对基本的正则表达式有一定的了解。</p>
<p>将一个语言绑定到另一个语言是一个不容小觑的任务。
为了让绑定可以工作，绑定语言需要理解目标语言的调用约定，类型系统，数据结构，内存分配机制和链接策略。
绑定系统需要仔细的调整两种语言的语义,以便让两种语言都能理解他们之间传递的数据。</p>
<p>对于 Haskell, 这个技术栈由 Haskell 报告外部函数接口附录(<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/haskell/ffi">the Foreign Function Interface addendum</a>)所指定。
FFI报告描述了如何正确的将 Haskell 和 C 语言绑定到一起，以及如何把绑定扩展到其他语言.该标准旨在实现可移植性, 因此 FFI 绑定可以在不同的 Haskell 实现，操作系统，C编译器上都可靠的工作。</p>
<p>所有 Haskell 的实现都支持FFI,并且在 Haskell 在新领域使用的时候这是一个关键技术。
我们只需要绑定到 Haskell 以外的语言所编写的现有库，而不是去重新实现域中的标准库。</p>
<p>FFI 为语言添加了一个灵活性的新维度: 如果我们因为某些原因需要访问原始硬件(比如我们在编写新硬件，或者是在实现操作系统）, FFI 可以让我们访问硬件。
它还为我们提供了一个解决性能问题的方法: 如果我们代码经常需要运行的部分总是不够快, 那么总是可以选择在 C 语言中再次尝试。那我们就来看一下 FFI 在实际编写代码中究竟意味着什么。</p>
<div class="section" id="foreign-language-bindings-the-basics">
<span id="id1"></span><h2>外部语言绑定：基础<a class="headerlink" href="#foreign-language-bindings-the-basics" title="Permalink to this headline">¶</a></h2>
<p>不出所料，我们最想要做的常见操作是从 Haskell 调用 C 语言中的函数。让我们通过绑定标准 C 库里的数学库来做到这一点。
我们将绑定放到源文件中, 将其编译为使用 C 语言代码的 Haskell 二进制文件。</p>
<p>首先,我们需要开启外部函数接口(FFI)扩展,因为默认情况下不启用 FFI 附录支持。我们一如既往的通过在源文件顶部添加 <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> 编译选项来执行这个操作:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/SimpleFFI.hs</span>
<span class="cm">{-# LANGUAGE ForeignFunctionInterface #-}</span>
</pre></div>
</div>
<p>LANGUAGE编译选项指示模块使用了 Haskell98 的哪些扩展。这次我们带来了 FFI 扩展。
追踪你需要的语言扩展是很重要的。较少的扩展通常意味着更加便携，更加健壮的代码。
实际上，尽管语言的语法，类型系统，核心库发生了变化，但是因为标准化，十多年去编写的 Haskell 程序在今天仍然可以完美的被编译。</p>
<p>下一步是导入 <code class="docutils literal notranslate"><span class="pre">Foreign</span></code> 模块,这个模块提供了一些有用的类型 (比如指针，数值类型，数组) 以及一些实用函数 (比如 <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">alloca</span></code>), 用于编写到其他语言的绑定:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/SimpleFFI.hs</span>
<span class="kr">import</span> <span class="nn">Foreign</span>
<span class="kr">import</span> <span class="nn">Foreign.C.Types</span>
</pre></div>
</div>
<p>对于与外部库的广泛工作, 熟悉 <code class="docutils literal notranslate"><span class="pre">Foreign</span></code> 模块是必不可少的。其他有用的模块包括 <code class="docutils literal notranslate"><span class="pre">Foreign.C.String</span></code>, <code class="docutils literal notranslate"><span class="pre">Foreign.Ptr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Foreign.Marshal.Array</span></code> 。</p>
<p>现在我们可以开始调用 C 语言的函数了。要做到这一点,我们需要知道三件事: C 语言的函数的名字,它的类型,以及相关的头文件。除此之外,如果代码不是C标准库提供的,我们还需要知道C库的名字,以便进行链接。
实际的绑定工作是由 <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">import</span></code> 声明完成的,如下所示:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/SimpleFFI.hs</span>
<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">ccall</span> <span class="s">&quot;math.h sin&quot;</span>
     <span class="n">c_sin</span> <span class="ow">::</span> <span class="kt">CDouble</span> <span class="ow">-&gt;</span> <span class="kt">CDouble</span>
</pre></div>
</div>
<p>这里定义了一个新的 Haskell 函数, <code class="docutils literal notranslate"><span class="pre">c_sin</span></code>, 它的具体实现是 C 语言中的 <code class="docutils literal notranslate"><span class="pre">sin</span></code> 函数。
当 <code class="docutils literal notranslate"><span class="pre">c_sin</span></code> 被调用时, 实际调用的是 <code class="docutils literal notranslate"><span class="pre">sin</span></code> 函数 (使用由 ccall 关键字指示的标准 C 调用规范)。Haskell runtime 将控制权传递给 C 语言，后者把结果返回给 Haskell 。然后把返回的结果包装为类型是 CDouble 的 Haskell 值。</p>
<p>编写 FFI 绑定是的习惯做法是使用前缀 “c_” 来暴露 C 语言函数, 将其与更加用户友好的高层函数区别开。在这个例子里原始的 C 语言函数由 <code class="docutils literal notranslate"><span class="pre">math.h</span></code> 头文件指定, 它被声明据有以下类型:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="nf">sin</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>在编写绑定时,程序员必须将 C 语言类型的签名转换为 Haskell FFI 的等价签名,来确保数据表现相匹配。例如 C 语言中 <code class="docutils literal notranslate"><span class="pre">double</span></code> 对应与 Haskell 中的 <code class="docutils literal notranslate"><span class="pre">CDouble</span></code> 。
在这里我们需要小心，因为假如出现了错误，Haskell 编译器依然会愉快的生成错误代码来调用 C 语言! 可怜的 Haskell 编译器不知道任何关于 C 语言函数实际需要什么类型的信息,所以如果这么做的话,它将使用错误的参数调用 C 语言函数。
最好的情况是C编译器会发出警告，不过这种情况更可能会导致程序运行时崩溃。最坏的情况下，错误将默默的被忽视，直到程序发生一些严重故障。所以请确保使用正确的FFI类型,并且不要担心使用QuickCheck通过绑定测试代码</p>
<p>[注： 一些更高级的绑定工具提供更大程度的类型检查，例如，c2hs 能够解析 C 语言的头文件，并且生成绑定定义，特别适用于指定完整API的大型项目]</p>
<p>最重要的原始 C 语言类型在 Haskell 中有一些直观的名称 (对于有符号和无符号类型) <code class="docutils literal notranslate"><span class="pre">CChar</span></code>, <code class="docutils literal notranslate"><span class="pre">CUChar</span></code>, <code class="docutils literal notranslate"><span class="pre">CInt</span></code>, <code class="docutils literal notranslate"><span class="pre">CUInt</span></code>, <code class="docutils literal notranslate"><span class="pre">CLong</span></code>, <code class="docutils literal notranslate"><span class="pre">CULong</span></code>, <code class="docutils literal notranslate"><span class="pre">CSize</span></code>, <code class="docutils literal notranslate"><span class="pre">CFloat</span></code>, <code class="docutils literal notranslate"><span class="pre">CDouble</span></code> 。更多内容在FFI标准中定义, 这些你可以在 <code class="docutils literal notranslate"><span class="pre">Foreign.C.Types</span></code> 下的 Haskell 基础库中找到。也可以为 C 语言定义你自己的 Haskell 端表示的类型,我们稍候就会看到。</p>
<div class="section" id="be-careful-of-side-effects">
<span id="id2"></span><h3>当心副作用<a class="headerlink" href="#be-careful-of-side-effects" title="Permalink to this headline">¶</a></h3>
<p>需要注意的一点是，我们将 <code class="docutils literal notranslate"><span class="pre">sin</span></code> 绑定为 Haskell 中的没有副作用的纯函数。
这本例中没问题，因为 C 语言中的 <code class="docutils literal notranslate"><span class="pre">sin</span></code> 函数是引用透明的。
通过将 C 语言纯函数绑定为 Haskell 纯函数，Haskell 编译器会获悉一些关于 C 语言代码的情况，即它没有副作用、更易于优化。
对于 Haskell 程序员来说纯的代码也是更灵活的代码，因为它自然产出持久数据结构以及线程安全函数。
虽然无副作用的 Haskell 代码总是线程安全的，但是 C 语言要做到这一点却难的多：
除非文档有明确声明一个函数“可重入（reentrant）”，否则的话，即使该函数看上去并没有产生副作用，它也无法确保同时是线程安全的。
无副作用且线程安全的 C 语言代码凤毛麟角、弥足珍贵——这就是在 Haskell 中使用 C 语言的最直观的感受。</p>
<p>当然，副作用代码在命令式语言中非常常见，其中语句的显式排列促进了副作用的使用。全局/局部状态的变化导致函数于给定相同的参数产生不同的返回值，或者函数具有其他副作用，这些情况在 C 语言中并不少见。
在 C 语言中，具有副作用的函数通常会返回一个状态值或者某种类型的空值，而不是一个有用的计算结果。
这意味着该函数的实际工作是通过副作用完成的。
对于这样的函数，我们需要在 IO monad 中捕获那些副作用（例如，将返回类型改为 <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">CDouble</span></code>）。
而对于不可重入的 C 语言纯函数，我们还需格外小心，因为与 C 语言相比，多线程在 Haskell 代码中极其常见。
我们可能需要通过一些措施让不可重入代码能够安全使用：使用事务锁缓和对 FFI 绑定的访问，或者复制（duplicating）底层 C 语言状态。</p>
</div>
<div class="section" id="a-high-level-wrapper">
<span id="id3"></span><h3>高级包装<a class="headerlink" href="#a-high-level-wrapper" title="Permalink to this headline">¶</a></h3>
<p>随着外部导入的搞定，下一步就是将外部语言调用中传递的 C 语言类型转换为 Haskell 原生类型，并包装相应绑定，使其呈现为正常的 Haskell 函数：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/SimpleFFI.hs</span>
<span class="nf">fastsin</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">fastsin</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">realToFrac</span> <span class="p">(</span><span class="n">c_sin</span> <span class="p">(</span><span class="n">realToFrac</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>为这样的绑定编写便利的包装器时，需要首要记住的事情是将输入与输出正确地转回正常 Haskell 类型。
要在浮点值之间进行转换，我们可以使用 <code class="docutils literal notranslate"><span class="pre">realToFrac</span></code>，这样我们可以将不同的浮点值相互转换（并且对于如从 <code class="docutils literal notranslate"><span class="pre">CDouble</span></code> 到 <code class="docutils literal notranslate"><span class="pre">Double</span></code> 的这类转换通常是无开销的，因为其底层表示并无变化）。
对于整型值可以使用 <code class="docutils literal notranslate"><span class="pre">fromIntegral</span></code>。
对于其他常见的 C 语言数据类型，例如数组，我们可能需要将数据解包为更可行的 Haskell 类型（例如列表），或者可能保持 C 语言数据的不透明（opaque）、而只是（可能通过 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code>）间接操作它。
具体选择取决于转换的成本以及源类型与目标类型上可用的函数。</p>
<p>现在我们可以继续在程序中使用已绑定的函数了。
例如，我们可以对一个 Haskell 的十分数列表（a Haskell list of tenths）应用 C 语言的 <code class="docutils literal notranslate"><span class="pre">sin</span></code>：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/SimpleFFI.hs</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">mapM_</span> <span class="p">(</span><span class="n">print</span> <span class="o">.</span> <span class="n">fastsin</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">10</span> <span class="o">..</span> <span class="mi">10</span><span class="o">/</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
<p>这个简单程序在计算每个结果的同时输出该结果。
将完整绑定放在文件 <code class="docutils literal notranslate"><span class="pre">SimpleFFI.hs</span></code> 中，我们可以在 <code class="docutils literal notranslate"><span class="pre">GHCi</span></code> 中运行它：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">ghci</span> <span class="kt">SimpleFFI</span><span class="o">.</span><span class="n">hs</span>
<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">main</span>
<span class="mf">0.0</span>
<span class="mf">9.983341664682815e-2</span>
<span class="mf">0.19866933079506122</span>
<span class="mf">0.2955202066613396</span>
<span class="mf">0.3894183423086505</span>
<span class="mf">0.479425538604203</span>
<span class="mf">0.5646424733950354</span>
<span class="mf">0.644217687237691</span>
<span class="mf">0.7173560908995227</span>
<span class="mf">0.7833269096274833</span>
<span class="mf">0.8414709848078964</span>
</pre></div>
</div>
<p>或者，我们可以将代码编译成可执行文件，并与相应的 C 语言库动态链接：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">ghc</span> <span class="o">-</span><span class="kt">O</span> <span class="c1">--make SimpleFFI.hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">SimpleFFI</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="kt">SimpleFFI</span><span class="o">.</span><span class="n">o</span> <span class="p">)</span>
<span class="kt">Linking</span> <span class="kt">SimpleFFI</span> <span class="o">...</span>
</pre></div>
</div>
<p>[译注：现在 ghc-7.6.3/ghc-8.0.2 也可以直接通过简单的 <code class="docutils literal notranslate"><span class="pre">ghc</span> <span class="pre">SimpleFFI.hs</span></code> 命令编译成可执行文件。]</p>
<p>然后运行：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="o">./</span><span class="kt">SimpleFFI</span>
<span class="mf">0.0</span>
<span class="mf">9.983341664682815e-2</span>
<span class="mf">0.19866933079506122</span>
<span class="mf">0.2955202066613396</span>
<span class="mf">0.3894183423086505</span>
<span class="mf">0.479425538604203</span>
<span class="mf">0.5646424733950354</span>
<span class="mf">0.644217687237691</span>
<span class="mf">0.7173560908995227</span>
<span class="mf">0.7833269096274833</span>
<span class="mf">0.8414709848078964</span>
</pre></div>
</div>
<p>我们现在做的很好，有一个完整的静态链接到 C 语言、C 代码与 Haskell 代码相交织、并跨过语言边界传数据的程序。
如上所述的简单绑定几乎是微不足道的，因为标准 <code class="docutils literal notranslate"><span class="pre">Foreign</span></code> 库为常用的类型提供了便利的别名，如 <code class="docutils literal notranslate"><span class="pre">CDouble</span></code>。
在下一节中，我们会介绍一个更大的工程任务：绑定到会引发内存管理和类型安全问题的 PCRE 库。</p>
</div>
</div>
<div class="section" id="haskell-pcre">
<span id="regular-expressions-for-haskell-a-binding-for-pcre"></span><h2>Haskell 的正则表达式：对 PCRE 的绑定<a class="headerlink" href="#haskell-pcre" title="Permalink to this headline">¶</a></h2>
<p>正如我们在之前章节中所看到的，Haskell 程序钟爱于列表作为基本数据结构。
列表函数是基础库的核心部分，并且构建和分离列表结构的便利语法已纳入到语言中。
字符串当然也是简单的字符列表（而不是平直的字符数组这种）。
这样的灵活性非常好，但是它导致标准库倾向于支持多态列表操作而牺牲字符串特有操作。</p>
<p>事实上，许多常见的任务都可以通过基于正则表达式的字符串处理来解决，但是正则表达式支持却不是 Haskell <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> 的一部分。
所以我们来看看如何使用现成的正则表达式库 PCRE，并为其提供一个自然、便利的 Haskell 绑定，让我们在 Haskell 中能够使用正则表达式。</p>
<p>PCRE 是一个实现 Perl 风格正则表达式的很普及的 C 语言库。
它广泛可用，并已预装在许多系统上。
如果未预装，可以在 <a class="reference external" href="http://www.pcre.org/">http://www.pcre.org/</a> 找到。
在下面的部分中，我们假设 PCRE 库和头文件已在机器上可用。</p>
<div class="section" id="c">
<span id="simple-tasks-using-the-c-preprocessor"></span><h3>简单任务：使用 C 语言预处理器<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h3>
<p>开始写一个新的 Haskell 到 C 语言的 FFI 绑定的最简单的任务是，将 C 语言头文件中定义的常量绑定到等同的 Haskell 值。
例如，PCRE 提供了一组用于修改核心模式匹配系统如何工作的标志（例如忽略大小写、或者允许匹配换行）。
这些标志是作为常量出现在 PCRE 头文件中的：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Options */</span>

<span class="cp">#define PCRE_CASELESS           0x00000001</span>
<span class="cp">#define PCRE_MULTILINE          0x00000002</span>
<span class="cp">#define PCRE_DOTALL             0x00000004</span>
<span class="cp">#define PCRE_EXTENDED           0x00000008</span>
</pre></div>
</div>
<p>要将这些值导出到 Haskell 中，我们需要以某种方式将它们插入到 Haskell 源文件中。
能做到这点的一个明显的方式是使用 C 语言的预处理器将 C 语言的定义转换到 Haskell 源代码中，然后我们可将该 Haskell 源代码作为正常 Haskell 源文件编译。
使用预处理器，我们甚至还可以通过 Haskell 源文件中的文本替换来声明简单的常量：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/Enum1.hs</span>
<span class="cm">{-# LANGUAGE CPP #-}</span>

<span class="o">#</span><span class="n">define</span> <span class="kt">N</span> <span class="mi">16</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">[</span> <span class="mi">1</span> <span class="o">..</span> <span class="kt">N</span> <span class="p">]</span>
</pre></div>
</div>
<p>预处理器处理该文件的方式与 C 源代码相同（当 Haskell 识别到 <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> 编译指示时，Haskell 编译器会为我们运行 CPP）
[译注：这里 CPP 即 C 语言预处理器，C Pre Processor，而不是 C++ 语言]，结果程序输出：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">runhaskell</span> <span class="kt">Enum1</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">]</span>
</pre></div>
</div>
<p>[译注：原文是运行 Enum.hs，这里与上面 Enum1.hs 代码匹配]</p>
<p>然而，依靠 CPP 是一种相当脆弱的方法。
C 语言预处理器并不知道它正在处理 Haskell 源文件，并会很愉快地包含文本或转换源代码，这会使我们的 Haskell 代码失效。
我们需要当心不要被 CPP 搅乱。
如果我们想要包含 C 语言头文件，我们会冒着这些风险：替换不需要的符号、或者将 C 语言类型信息与原型插入到 Haskell 源代码中，从而导致一团糟。</p>
<p>为了解决这些问题，随 GHC 一起分发了绑定预处理器 <code class="docutils literal notranslate"><span class="pre">hsc2hs</span></code>。
它提供了用于在 Haskell 中包含 C 语言绑定信息的便利语法，并且让我们安全地操作头文件。
它是大多数 Haskell FFI 绑定的首选工具。</p>
</div>
<div class="section" id="hsc2hs-haskell-c">
<span id="binding-haskell-to-c-with-hsc2hs"></span><h3>用 hsc2hs 将 Haskell 绑定到 C 语言<a class="headerlink" href="#hsc2hs-haskell-c" title="Permalink to this headline">¶</a></h3>
<p>如要使用 hsc2hs 作为 Haskell 的智能绑定工具，我们需要创建一个 <code class="docutils literal notranslate"><span class="pre">.hsc</span></code> 文件： <code class="docutils literal notranslate"><span class="pre">Regex.hsc</span></code>，该文件会包含用于绑定的 Haskell 源代码、hsc2hs 处理规则、C 语言头文件与 C 语言类型信息。
如要开始，我们需要一些编译指示与导入：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/Regex0.hsc</span>
<span class="cm">{-# LANGUAGE CPP, ForeignFunctionInterface #-}</span>

<span class="kr">module</span> <span class="nn">Regex</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Foreign</span>
<span class="kr">import</span> <span class="nn">Foreign.C.Types</span>

<span class="o">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">pcre</span><span class="o">.</span><span class="n">h</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>[译注：原文代码文件名为 Regex-hsc.hs，根据实际情况改为 Regex0.hsc]</p>
<p>该模块以 FFI 绑定的典型序文开头：启用 CPP、启用外部函数接口语法、声明模块名、然后从基础库导入一些内容。
不寻常项是最后一行，我们在那里包含了 PCRE 的 C 语言头文件。
这在 <code class="docutils literal notranslate"><span class="pre">.hs</span></code> 源文件中是无效的，但是在 <code class="docutils literal notranslate"><span class="pre">.hsc</span></code> 代码中却有效。</p>
</div>
<div class="section" id="pcre">
<span id="adding-type-safety-to-pcre"></span><h3>给 PCRE 添加类型安全<a class="headerlink" href="#pcre" title="Permalink to this headline">¶</a></h3>
<p>接下来，我们需要一个类型来表示 PCRE 编译期标志。
在 C 语言中，这些都是 <code class="docutils literal notranslate"><span class="pre">compile</span></code> 函数的整数标志，所以我们可以只是使用 <code class="docutils literal notranslate"><span class="pre">CInt</span></code> 来表示它们。
据我们对该变量的了解，它们是 C 语言中的数字常量，所以 <code class="docutils literal notranslate"><span class="pre">CInt</span></code> 就是恰当的表示。</p>
<p>尽管作为一名 Haskell 库的作者，还是觉得这很草率。
可以用作正则表达式标志的值的类型所包含的值比 <code class="docutils literal notranslate"><span class="pre">CInt</span></code> 允许的值要少。
这会无法阻止最终用户传入非法整数值作为参数，或混用只能在正则表达式编译期传入的标志与运行时标志。
也可以对标志进行任意数学运算，或者进行其他使整数和标志混淆的错误操作。
我们真的需要更精确地指出标志的类型不同于其运行时表示（作为数值）。
如果可以这样做，我们就能静态地防止一些滥用标志相关的错误。</p>
<p>添加一个这样的类型安全层比较容易，并且这是类型引入声明 <code class="docutils literal notranslate"><span class="pre">newtype</span></code> 的一个很好的用例。
<code class="docutils literal notranslate"><span class="pre">newtype</span></code> 能让我们做的是创建一个与另一类型具有同一运行时表示、但在编译期作为独立类型的一个类型。
我们可以将标志表示为 <code class="docutils literal notranslate"><span class="pre">CInt</span></code> 值，但是在编译期它们会由类型检查器区别标记。
当使用错误标志值（因为我们只指定那些有效的标志，并且阻止访问数据构造器）、或者将标志传给期待整数的函数时，这会导致类型错误。
我们可以使用 Haskell 类型系统为 C 语言 PCRE API 引入类型安全的层。</p>
<p>为此，我们为 PCRE 编译期选项定义了一个 <code class="docutils literal notranslate"><span class="pre">newtype</span></code>，其内部表示实际上是一个 <code class="docutils literal notranslate"><span class="pre">CInt</span></code> 值，如下所示：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/Regex0.hsc</span>
<span class="c1">-- | A type for PCRE compile-time options. These are newtyped CInts,</span>
<span class="c1">-- which can be bitwise-or&#39;d together, using &#39;(Data.Bits..|.)&#39;</span>
<span class="c1">--</span>
<span class="kr">newtype</span> <span class="kt">PCREOption</span> <span class="ow">=</span> <span class="kt">PCREOption</span> <span class="p">{</span> <span class="n">unPCREOption</span> <span class="ow">::</span> <span class="kt">CInt</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>[译注：原文代码文件名为 Regex-hsc.hs，根据实际情况改为 Regex0.hsc]</p>
<p>该类型名为 <code class="docutils literal notranslate"><span class="pre">PCREOption</span></code>，它有一个单一的构造器，也命名为 <code class="docutils literal notranslate"><span class="pre">PCREOption</span></code>，它通过将构造器包装起来而将 <code class="docutils literal notranslate"><span class="pre">CInt</span></code> 值提升为新类型。
我们还可以使用 Haskell 记录语法愉快地定义一个到其底层类型 <code class="docutils literal notranslate"><span class="pre">CInt</span></code> 的访问器 <code class="docutils literal notranslate"><span class="pre">unPCREOption</span></code>。
在同一行内这很方便。
此处我们也可以为标志继承一些有用的类型类操作（如相等性与可输出）。
我们还需记住从源模块抽象地导出数据构造器，确保用户不能构建自己的 <code class="docutils literal notranslate"><span class="pre">PCREOption</span></code> 值。</p>
</div>
<div class="section" id="binding-to-constants">
<span id="id4"></span><h3>绑定到常量<a class="headerlink" href="#binding-to-constants" title="Permalink to this headline">¶</a></h3>
<p>现在我们已经导入了所需的模块、开启了我们需要的语言特性、并定义了一种表示 PCRE 选项的类型，我们需要实际定义一些与这些 PCRE 常量相对应的 Haskell 值。</p>
<p>我们可以用 hsc2hs 以两种方式来做到这一点。
第一种方法是使用 hsc2hs 提供的 <code class="docutils literal notranslate"><span class="pre">#const</span></code> 关键字。
这让我们可以命名由 C 语言预处理器提供的常量。
我们可以通过使用 <code class="docutils literal notranslate"><span class="pre">#const</span></code> 关键字列出 CPP 符号来手动绑定常量：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/Regex0.hsc</span>
<span class="nf">caseless</span>       <span class="ow">::</span> <span class="kt">PCREOption</span>
<span class="nf">caseless</span>       <span class="ow">=</span> <span class="kt">PCREOption</span> <span class="o">#</span><span class="n">const</span> <span class="kt">PCRE_CASELESS</span>

<span class="nf">dollar_endonly</span> <span class="ow">::</span> <span class="kt">PCREOption</span>
<span class="nf">dollar_endonly</span> <span class="ow">=</span> <span class="kt">PCREOption</span> <span class="o">#</span><span class="n">const</span> <span class="kt">PCRE_DOLLAR_ENDONLY</span>

<span class="nf">dotall</span>         <span class="ow">::</span> <span class="kt">PCREOption</span>
<span class="nf">dotall</span>         <span class="ow">=</span> <span class="kt">PCREOption</span> <span class="o">#</span><span class="n">const</span> <span class="kt">PCRE_DOTALL</span>
</pre></div>
</div>
<p>[译注：原文代码文件名为 Regex-hsc-const.hs，根据实际情况改为 Regex0.hsc]</p>
<p>这在 Haskell 这边引入了三个新的常量： <code class="docutils literal notranslate"><span class="pre">caseless</span></code>、 <code class="docutils literal notranslate"><span class="pre">dollar_endonly</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">dotall</span></code>，对应于类似命名的 C 语言定义。
我们立即将这些常量包装在一个 newtype 构造器中，因此它们仅作为抽象的 <code class="docutils literal notranslate"><span class="pre">PCREOption</span></code> 类型暴露给程序员。</p>
<p>这是第一步，创建了一个 <code class="docutils literal notranslate"><span class="pre">.hsc</span></code> 文件。
C 语言预处理完成后，我们现在需要实际创建一个 Haskell 源文件。
是时候对  <code class="docutils literal notranslate"><span class="pre">.hsc</span></code> 文件运行 <code class="docutils literal notranslate"><span class="pre">hsc2hs</span></code> 了：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">hsc2hs</span> <span class="kt">Regex0</span><span class="o">.</span><span class="n">hsc</span>
</pre></div>
</div>
<p>[译注：原文代码文件名为 Regex.hsc，根据实际情况改为 Regex0.hsc]</p>
<p>这会创建一个新的输出文件 <code class="docutils literal notranslate"><span class="pre">Regex0.hs</span></code>，其中的 CPP 变量已经扩展，并产生有效的 Haskell 代码：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/Regex0.hs</span>
<span class="nf">caseless</span>       <span class="ow">::</span> <span class="kt">PCREOption</span>
<span class="nf">caseless</span>       <span class="ow">=</span> <span class="kt">PCREOption</span> <span class="mi">1</span>
<span class="cm">{-# LINE 21 &quot;Regex.hsc&quot; #-}</span>

<span class="nf">dollar_endonly</span> <span class="ow">::</span> <span class="kt">PCREOption</span>
<span class="nf">dollar_endonly</span> <span class="ow">=</span> <span class="kt">PCREOption</span> <span class="mi">32</span>
<span class="cm">{-# LINE 24 &quot;Regex.hsc&quot; #-}</span>

<span class="nf">dotall</span>         <span class="ow">::</span> <span class="kt">PCREOption</span>
<span class="nf">dotall</span>         <span class="ow">=</span> <span class="kt">PCREOption</span> <span class="mi">4</span>
<span class="cm">{-# LINE 27 &quot;Regex.hsc&quot; #-}</span>
</pre></div>
</div>
<p>[译注：原文代码文件名为 Regex-hsc-const-generated.hs，根据实际情况改为 Regex0.hs]</p>
<p>还请注意， <code class="docutils literal notranslate"><span class="pre">.hsc</span></code> 的原始行号是如何通过 <code class="docutils literal notranslate"><span class="pre">LINE</span></code> 编译指示列在每个定义展开之后的。
编译器使用这些信息依照其原始文件中的源代码而不是所生成的代码报告错误。
我们可以将这个生成的 <code class="docutils literal notranslate"><span class="pre">.hs</span></code> 文件加载到解释器中，并使用其结果：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">ghci</span> <span class="kt">Regex0</span><span class="o">.</span><span class="n">hs</span>
<span class="o">*</span><span class="kt">Regex</span><span class="o">&gt;</span> <span class="n">caseless</span>
<span class="kt">PCREOption</span> <span class="p">{</span><span class="n">unPCREOption</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">}</span>
<span class="o">*</span><span class="kt">Regex</span><span class="o">&gt;</span> <span class="n">unPCREOption</span> <span class="n">caseless</span>
<span class="mi">1</span>
<span class="o">*</span><span class="kt">Regex</span><span class="o">&gt;</span> <span class="n">unPCREOption</span> <span class="n">caseless</span> <span class="o">+</span> <span class="n">unPCREOption</span> <span class="n">caseless</span>
<span class="mi">2</span>
<span class="o">*</span><span class="kt">Regex</span><span class="o">&gt;</span> <span class="n">caseless</span> <span class="o">+</span> <span class="n">caseless</span>
<span class="nf">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Num</span> <span class="kt">PCREOption</span><span class="p">)</span>
</pre></div>
</div>
<p>[译注：原文代码文件名为 Regex.hs，根据实际情况改为 Regex0.hs]</p>
<p>所以都按预期运转。
该值是不透明的，如果尝试破坏抽象，我们会得到类型错误，而如果需要，我们可以解开它们并对它们进行操作。
<code class="docutils literal notranslate"><span class="pre">unPCREOption</span></code> 访问器用于打开该封装。
这是一个好的开始，不过让我们看下我们可以如何进一步简化这个任务。</p>
</div>
<div class="section" id="automating-the-binding">
<span id="id5"></span><h3>自动绑定<a class="headerlink" href="#automating-the-binding" title="Permalink to this headline">¶</a></h3>
<p>显然，手动列出所有 C 语言定义并包装它们是乏味的、且容易出错。
在 <code class="docutils literal notranslate"><span class="pre">newtype</span></code> 构造器中包装所有字面值的工作也令人厌烦。
这种绑定是一个非常常见的任务，因此 <code class="docutils literal notranslate"><span class="pre">hsc2hs</span></code> 提供了便利的语法来自动化进行： <code class="docutils literal notranslate"><span class="pre">#enum</span></code> 结构。</p>
<p>我们可以用以下等效形式替换我们的顶层绑定列表：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/Regex.hsc</span>
<span class="c1">-- PCRE compile options</span>
<span class="o">#</span><span class="p">{</span><span class="n">enum</span> <span class="kt">PCREOption</span><span class="p">,</span> <span class="kt">PCREOption</span>
  <span class="p">,</span> <span class="n">caseless</span>             <span class="ow">=</span> <span class="kt">PCRE_CASELESS</span>
  <span class="p">,</span> <span class="n">dollar_endonly</span>       <span class="ow">=</span> <span class="kt">PCRE_DOLLAR_ENDONLY</span>
  <span class="p">,</span> <span class="n">dotall</span>               <span class="ow">=</span> <span class="kt">PCRE_DOTALL</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>[译注：原文代码文件名为 Regex-hsc.hs，根据实际情况应该是 Regex.hsc]</p>
<p>这要简洁很多！ <code class="docutils literal notranslate"><span class="pre">#enum</span></code> 结构给了我们三个要使用的字段。
第一个名称是我们希望 C 语言定义转换后的类型名。
这样我们可以选择绑定到除了 <code class="docutils literal notranslate"><span class="pre">CInt</span></code> 之外的其他类型。
我们选择的是用 <code class="docutils literal notranslate"><span class="pre">PCREOption</span></code> 来构建。</p>
<p>第二个字段是可选的放在符号前面的构造器。
这专门针对我们想要构造 <code class="docutils literal notranslate"><span class="pre">newtype</span></code> 值的情况，并且会节约很多啰嗦的工作。
<code class="docutils literal notranslate"><span class="pre">#enum</span></code> 语法的最后一部分是自解释的：它只是定义了会由 CPP 填充的常量的 Haskell 名称。</p>
<p>像之前一样，通过 hsc2hs 运行这段代码，会生成一个 Haskell 文件，其中生成了以下绑定代码（为简洁起见删除了 <code class="docutils literal notranslate"><span class="pre">LINE</span></code> 编译指示）：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/Regex.hs</span>
<span class="nf">caseless</span>              <span class="ow">::</span> <span class="kt">PCREOption</span>
<span class="nf">caseless</span>              <span class="ow">=</span> <span class="kt">PCREOption</span> <span class="mi">1</span>
<span class="nf">dollar_endonly</span>        <span class="ow">::</span> <span class="kt">PCREOption</span>
<span class="nf">dollar_endonly</span>        <span class="ow">=</span> <span class="kt">PCREOption</span> <span class="mi">32</span>
<span class="nf">dotall</span>                <span class="ow">::</span> <span class="kt">PCREOption</span>
<span class="nf">dotall</span>                <span class="ow">=</span> <span class="kt">PCREOption</span> <span class="mi">4</span>
</pre></div>
</div>
<p>太完美了。
现在我们可以使用这些值在 Haskell 中做一些事情。
我们的目标是将标志视为抽象类型，而不是 C 语言中的整数位域。
在 C 语言中传入多个标志可通过将多个标志位或在一起来完成。
而对于一个抽象类型来说，这会暴露过多的信息。
为保持抽象并赋予其 Haskell 风格，我们希望用户以列表形式传入多个标志而由库自身来组合。
这可以通过简单的 fold 来实现：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/Regex.hs</span>
<span class="c1">-- | Combine a list of options into a single option, using bitwise (.|.)</span>
<span class="nf">combineOptions</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">PCREOption</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">PCREOption</span>
<span class="nf">combineOptions</span> <span class="ow">=</span> <span class="kt">PCREOption</span> <span class="o">.</span> <span class="n">foldr</span> <span class="p">((</span><span class="o">.|.</span><span class="p">)</span> <span class="o">.</span> <span class="n">unPCREOption</span><span class="p">)</span> <span class="mi">0</span>
</pre></div>
</div>
<p>这个简单的循环以初始值 0 开始、解包每个标志、并在底层 <code class="docutils literal notranslate"><span class="pre">CInt</span></code> 上用位或 <code class="docutils literal notranslate"><span class="pre">(.|.)</span></code> 通过循环累积器来组合每个值。
最后的累积状态会随即包装在 <code class="docutils literal notranslate"><span class="pre">PCREOption</span></code> 构造器中。</p>
<p>现在轮到我们实际编译一些正则表达式了。</p>
</div>
</div>
<div class="section" id="haskell-c">
<h2>在 Haskell 与 C 语言之间传递字符串数据<a class="headerlink" href="#haskell-c" title="Permalink to this headline">¶</a></h2>
<p>下一个任务是编写一个到 PCRE 正则表达式编译函数 <code class="docutils literal notranslate"><span class="pre">compile</span></code> 的绑定。
我们直接在 <code class="docutils literal notranslate"><span class="pre">pcre.h</span></code> 头文件中看看它的类型：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pcre</span> <span class="o">*</span><span class="nf">pcre_compile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pattern</span><span class="p">,</span>
                   <span class="kt">int</span> <span class="n">options</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">errptr</span><span class="p">,</span>
                   <span class="kt">int</span> <span class="o">*</span><span class="n">erroffset</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tableptr</span><span class="p">);</span>
</pre></div>
</div>
<p>这个函数将正则表达式模式编译成一些内部格式，它接受模式、一些标志以及返回状态信息的一些变量作为参数。</p>
<p>我们需要找出用来表示每个参数的 Haskell 类型。
这些类型中的大多数已经由 FFI 标准定义的等价形式所覆盖，并且在 <code class="docutils literal notranslate"><span class="pre">Foreign.C.Types</span></code> 中可用。
第一个参数，正则表达式自身，作为一个空结尾的 char 指针传给 C 语言，等价于 Haskell 中的 <code class="docutils literal notranslate"><span class="pre">CString</span></code> 类型。
PCRE 编译器选项，我们已经选用表示为抽象的 newtype <code class="docutils literal notranslate"><span class="pre">PCREOption</span></code>，其运行时表示是一个 <code class="docutils literal notranslate"><span class="pre">CInt</span></code>。
由于该表示保障同一，因此我们可以安全地传入该 <code class="docutils literal notranslate"><span class="pre">newtype</span></code>。
其他的参数有点复杂，需要一些工作来构造和分解。</p>
<p>第三个参数，一个指向 C 语言字符串的指针，将用作编译表达式时所生成任何错误信息的引用。
该指针的值会被 C 语言函数修改为指向自定义的错误字符串。
这可以用 <code class="docutils literal notranslate"><span class="pre">Ptr</span> <span class="pre">CString</span></code> 类型来表示。
Haskell 中的指针是用于原始地址的堆分配的容器，并且可以使用 FFI 库中的若干个分配原语来创建和操作。
例如，我们可以将一个指向 C 语言 <code class="docutils literal notranslate"><span class="pre">int</span></code> 的指针表示为 <code class="docutils literal notranslate"><span class="pre">Ptr</span> <span class="pre">CInt</span></code>、并将一个指向 unsigned char 的指针表示为 <code class="docutils literal notranslate"><span class="pre">Ptr</span> <span class="pre">Word8</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>关于指针的注意事项</p>
<p>一旦我们有一个 Haskell 的 <code class="docutils literal notranslate"><span class="pre">Ptr</span></code> 值，我们就可以用它来做各种类似指针的事情。
我们可以将其与空指针（用特殊常量 <code class="docutils literal notranslate"><span class="pre">nullPtr</span></code> 表示）进行比较。
我们可以将指针从一个类型转换为另一个指针类型，或者我们可以使用 <code class="docutils literal notranslate"><span class="pre">plusPtr</span></code> 以字节数偏移量移动一个指针。
我们还可以使用 <code class="docutils literal notranslate"><span class="pre">poke</span></code> 修改它指向的值，当然也可以使用 <code class="docutils literal notranslate"><span class="pre">peek</span></code> 解引用一个指针并产生它所指向的值。
在大多数情况下，Haskell 程序员不需要直接操作指针，但是当需要时，这些工具就会派上用场。</p>
</div>
<p>那么问题是如何表示当我们编译正则表达式时返回的抽象 <code class="docutils literal notranslate"><span class="pre">pcre</span></code> 指针。
我们需要找到一个像该 C 语言类型一样抽象的 Haskell 类型。
由于该 C 语言类型被抽象地处理，我们可以为该数据赋值给任何堆分配的 Haskell 类型，只要其上没有或几乎没有操作即可。
这是应对任意类型外部数据的常用技巧。
用于表示未知外部数据的惯用简单类型是指向 <code class="docutils literal notranslate"><span class="pre">()</span></code> 类型的指针。
我们可以使用类型别名记住该绑定：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/PCRE-compile0.hs</span>
<span class="kr">type</span> <span class="kt">PCRE</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>[译注：原文代码文件名为 PCRE-compile.hs，根据实际情况改为 PCRE-compile0.hs]</p>
<p>也就是说，外部数据是一些未知的、不透明的对象，而我们只是将其视为指向 <code class="docutils literal notranslate"><span class="pre">()</span></code> 的指针，我们清楚地知道我们永远不会真正解引用该指针。
这为我们提供了 <code class="docutils literal notranslate"><span class="pre">pcre_compile</span></code> 的以下外部导入绑定，它必须在 <code class="docutils literal notranslate"><span class="pre">IO</span></code> 中，因为不同的调用它返回的指针会有所不同，即使返回的对象在功能上是等价的：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/PCRE-compile0.hs</span>
<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">ccall</span> <span class="n">unsafe</span> <span class="s">&quot;pcre.h pcre_compile&quot;</span>
    <span class="n">c_pcre_compile</span>  <span class="ow">::</span> <span class="kt">CString</span>
                    <span class="ow">-&gt;</span> <span class="kt">PCREOption</span>
                    <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">CString</span>
                    <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">CInt</span>
                    <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">Word8</span>
                    <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Ptr</span> <span class="kt">PCRE</span><span class="p">)</span>
</pre></div>
</div>
<p>[译注：原文代码文件名为 PCRE-compile.hs，根据实际情况改为 PCRE-compile0.hs]</p>
<div class="section" id="id6">
<h3>类型化的指针<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>关于安全的注意事项</p>
<p>当进行外部导入声明时，我们可以可选地通过 <code class="docutils literal notranslate"><span class="pre">safe</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">unsafe</span></code> 关键字指定一个当调用时使用的“安全性”等级。
安全调用效率较低，但是保证 Haskell 系统能够在 C 语言中安全地调用。
一个“不安全的”调用的开销要少得多，但是所调用 C 语言代码不能回调到 Haskell 中。
默认的外部导入是“安全的”，但实践中 C 语言代码很少会回调到 Haskell 中，所以为了效率，我们主要使用“不安全的”调用。</p>
</div>
<p>我们可以通过使用“类型化的”（而不是使用 <code class="docutils literal notranslate"><span class="pre">()</span></code> 类型）指针来进一步增强绑定的安全性。
也就是说，与单元类型不同的、没有有意义的运行时表示的唯一类型。
一种不能构造数据、解引用会导致类型错误的类型。
构建这样已知不可探查的数据类型的一个好方式是使用空元（nullary）数据类型：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/PCRE-nullary.hs</span>
<span class="kr">data</span> <span class="kt">PCRE</span>
</pre></div>
</div>
<p>这需要 <code class="docutils literal notranslate"><span class="pre">EmptyDataDecls</span></code> 语言扩展[译注：新版 ghc-7.6.3/ghc-8.0.2 无需配置此扩展]。
这种类型显然没有值！
我们只能构造指向这些值的指针，因为没有具有这种类型的具体值（除了 bottom）。
[译注：关于 bottom 请参见第 26 章或者：<a class="reference external" href="http://www.haskell.org/haskellwiki/Bottom">http://www.haskell.org/haskellwiki/Bottom</a> ]</p>
<p>再次重复，我们不能真正对这样的值做任何事情，因为它没有运行时表示。
以这样的方式使用类型化的指针只是为 C 语言所提供功能之上的 Haskell 层添加安全性的另一种方式。
对于 C 语言程序员方面需要遵守的规定 （请记住永远不要解引用 PCRE 指针）可以在 Haskell 绑定的类型系统中静态强制执行。
如果这段代码通过编译，那么类型检查器给了我们一个这样的凭证：C 语言返回的 PCRE 对象在 Haskell 端决不会解引用。</p>
<p>现在我们已经将外部导入声明整理好，下一步是将数据编排成正确的形式，这样我们就可以最终调用 C 语言代码了。</p>
</div>
<div class="section" id="id7">
<h3>内存管理：让垃圾回收器司其职<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>一个尚未解决的问题是如何管理与 C 语言库返回的抽象 <code class="docutils literal notranslate"><span class="pre">PCRE</span></code> 结构相关联的内存。
调用者无需分配它：该库通过在 C 语言端分配内存来处理这个问题。
在某个时间点我们需要回收它。
这又是一个通过隐藏 Haskell 绑定内部复杂性来抽象对于 C 语言乏味使用的机会。</p>
<p>我们会使用 Haskell 垃圾收集器在不再使用时自动回收 C 语言结构。
为此，我们会利用 Haskell 垃圾收集器终结器（finalizer）与 <code class="docutils literal notranslate"><span class="pre">ForeignPtr</span></code> 类型。</p>
<p>我们不希望用户必须手动回收外部调用返回的 <code class="docutils literal notranslate"><span class="pre">Ptr</span> <span class="pre">PCRE</span></code> 值。
PCRE 库特别指出，在 C 语言端结构是由 <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 分配的，而在不再使用时需要释放它，否则会有内存泄漏的风险。
Haskell 垃圾回收器已经使管理 Haskell 值的内存的任务很大程度上自动化了。
我们也可以巧妙地给我们勤奋的垃圾回收器关联上为我们照看 C 语言内存的任务。
诀窍是将一块 Haskell 数据与外部分配器数据关联，并给 Haskell 垃圾收集器一个任意函数，一旦该函数注意到 Haskell 数据用完就回收相应 C 语言资源。</p>
<p>这里我们有两个工具，不透明的 <code class="docutils literal notranslate"><span class="pre">ForeignPtr</span></code> 数据类型以及具有以下类型的 <code class="docutils literal notranslate"><span class="pre">newForeignPtr</span></code> 函数：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/ForeignPtr.hs</span>
<span class="nf">newForeignPtr</span> <span class="ow">::</span> <span class="kt">FinalizerPtr</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">ForeignPtr</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>[译注：标准库定义，非本章代码，无对应文件]</p>
<p>该函数有两个参数，一个在数据离开作用域时运行的终结器，以及一个指向所关联 C 语言数据的指针。
它返回一个新的托管的指针，一旦垃圾收集器决定不再使用相应数据，该指针就会运行其终结器。
多优美的抽象！</p>
<p>这些可终结的指针适用于一个 C 语言库需要用户显式回收的任何事物，以及当不再使用时清理资源。
这是一个简单的装备，它非常有助于使 C 语言库绑定的风格更加自然、更加函数式。</p>
<p>因此，考虑到这一点，我们可以把手动管理的 <code class="docutils literal notranslate"><span class="pre">Ptr</span> <span class="pre">PCRE</span></code> 类型隐藏在自动管理的数据结构中，从而产生用于表示用户将会看到的正则表达式的数据类型：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/PCRE-compile.hs</span>
<span class="kr">data</span> <span class="kt">Regex</span> <span class="ow">=</span> <span class="kt">Regex</span> <span class="o">!</span><span class="p">(</span><span class="kt">ForeignPtr</span> <span class="kt">PCRE</span><span class="p">)</span>
                   <span class="o">!</span><span class="kt">ByteString</span>
        <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>这个新的 <code class="docutils literal notranslate"><span class="pre">Regex</span></code> 数据类型由两部分组成。
第一个是抽象的 <code class="docutils literal notranslate"><span class="pre">ForeignPtr</span></code>，我们会用它来管理在 C 语言中分配的底层 <code class="docutils literal notranslate"><span class="pre">PCRE</span></code> 数据。
第二个组件是严格的 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code>，它是我们所编译的正则表达式的字符串表示形式。
通过使 <code class="docutils literal notranslate"><span class="pre">Regex</span></code> 类型内部的正则表达式的用户级表示保持便利，输出友好的错误消息、以有意义的方式显示 <code class="docutils literal notranslate"><span class="pre">Regex</span></code> 自身都会更容易。</p>
</div>
<div class="section" id="id8">
<h3>高级接口：数据编排<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>编写 FFI 绑定时，一旦 Haskell 类型确定，挑战就是将 Haskell 程序员熟悉的常规数据类型转换为低层级的数组的指针以及其他 C 语言类型。
正则表达式编译的理想 Haskell 接口是什么样的？
有一些设计直觉来指导我们。</p>
<p>对于初学者来说，编译行为应该是一个引用透明的操作：传递相同的正则表达式字符串每次都会产生功能上相同的编译模式，尽管 C 语言库会给我们可观察到不同的指向同一功能的表达式的指针。
如果我们可以隐藏这些内存管理细节，我们应该能够将绑定表示为纯函数。
将 C 语言函数表示为 Haskell 中的纯操作的能力，是迈向灵活性的关键步骤，也是该接口易于使用（因为在使用前不需要初始化复杂状态）的指标。</p>
<p>就算是纯函数也可以失败。
如果用户提供的正则表达式输入格式错误，就返回一个错误字符串。
表示带有错误值的可选失败的一个很好的数据类型是 <code class="docutils literal notranslate"><span class="pre">Either</span></code>。
也就是说，要么我们返回一个有效的编译过的正则表达式，要么我们会返回一个错误字符串。
将一个 C 语言函数的结果编码为这种熟悉的基本 Haskell 类型，是使该绑定更合乎惯用法的另一个有用步骤。</p>
<p>对于用户提供的参数，我们已经决定以列表的形式传递编译标志。
我们可以选择将输入正则表达式作为一个高效的 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 传递，或者作为一个常规的 <code class="docutils literal notranslate"><span class="pre">String</span></code> 来传递。
那么，对于引用透明的编译成功时得到一个值、失败时得到一个错误字符串（的函数）的适宜的类型签名会是这样：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/PCRE-compile.hs</span>
<span class="nf">compile</span> <span class="ow">::</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">PCREOption</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Regex</span>
</pre></div>
</div>
<p>输入是一个 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code>，可以从 <code class="docutils literal notranslate"><span class="pre">Data.ByteString.Char8</span></code> 模块中获得（我们将以此 <code class="docutils literal notranslate"><span class="pre">qualified</span></code> 导入来避免名字冲突），它包含正则表达式；以及一个标志列表（或者空列表，如果没有标志可传的话）。
其结果要么是一个错误字符串，要么是一个新编译的正则表达式。</p>
</div>
<div class="section" id="bytestring">
<h3>编排 ByteString<a class="headerlink" href="#bytestring" title="Permalink to this headline">¶</a></h3>
<p>给定这种类型，我们可以勾画出 <code class="docutils literal notranslate"><span class="pre">compile</span></code> 函数：对原始 C 语言绑定的高级接口。
在其核心会调用 <code class="docutils literal notranslate"><span class="pre">c_pcre_compile</span></code>。
在这之前，它必须将输入 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 编入一个 <code class="docutils literal notranslate"><span class="pre">CString</span></code>。
这是通过 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 库的 <code class="docutils literal notranslate"><span class="pre">useAsCString</span></code> 函数来完成的，它将输入的 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 复制到一个空结尾的 C 语言数组中（也有一个不安全的零拷贝变体，它假定 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 已经是空结尾）：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/ForeignPtr.hs</span>
<span class="nf">useAsCString</span> <span class="ow">::</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">CString</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
</pre></div>
</div>
<p>[译注：标准库定义，非本章代码，无对应文件]</p>
<p>该函数使用一个 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 作为输入。
第二个参数是一个用户定义的函数，该函数运行时使用所生成的 <code class="docutils literal notranslate"><span class="pre">CString</span></code>。
我们在这里看到另一个有用的惯用法：数据编排函数由闭包自然界定。
我们的 <code class="docutils literal notranslate"><span class="pre">useAsCString</span></code> 函数将把输入数据转换成一个 C 语言字符串，然后我们可以传给 C 语言作为一个指针。
然后我们的负担就是提供一大堆代码来调用 C 语言。</p>
<p>这种风格的代码通常用一个缩进的“do-代码块”表示法来写。
以下伪代码说明了这一结构：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/DoBlock.hs</span>
<span class="nf">useAsCString</span> <span class="n">str</span> <span class="o">$</span> <span class="nf">\</span><span class="n">cstr</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
   <span class="o">...</span> <span class="n">operate</span> <span class="n">on</span> <span class="n">the</span> <span class="kt">C</span> <span class="n">string</span>
   <span class="o">...</span> <span class="n">return</span> <span class="n">a</span> <span class="n">result</span>
</pre></div>
</div>
<p>[译注：伪代码，无对应文件]</p>
<p>这里的第二个参数是一个匿名函数，一个函数体是单子化的“do”代码块的 lambda 表达式。
通常使用简单的 <code class="docutils literal notranslate"><span class="pre">($)</span></code> 应用操作符来避免使用括号分隔代码块参数。
在处理这样的代码块参数时，这是一个很有用的惯用法。</p>
</div>
<div class="section" id="c-storable">
<h3>分配本地 C 语言数据（内存）：Storable 类<a class="headerlink" href="#c-storable" title="Permalink to this headline">¶</a></h3>
<p>我们可以很高兴地将 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 数据编排为 C 语言兼容类型，但是 <code class="docutils literal notranslate"><span class="pre">pcre_compile</span></code> 函数还需要一些指针与数组来放置它的其他返回值。
这些都只应该短暂存在，所以我们不需要复杂的分配策略。
可以使用 <code class="docutils literal notranslate"><span class="pre">alloca</span></code> 函数创建这样的短期 C 语言数据：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/ForeignPtr.hs</span>
<span class="nf">alloca</span> <span class="ow">::</span> <span class="kt">Storable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="kt">Ptr</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">b</span>
</pre></div>
</div>
<p>[译注：标准库定义，非本章代码，无对应文件]</p>
<p>这个函数接受一个代码块，该代码块接受一个某种 C 语言类型的指针作为参数。函数会安排用新分配的、未初始化的正确大小的数据调用该代码块。
这种分配机制将局部堆栈变量镜像到其他语言中。
一旦参数函数退出就释放所分配的内存。
以这种方式，我们让低级数据类型在词法级作用域分配，保证在退出作用域后释放。
我们可以用它来分配具有 <code class="docutils literal notranslate"><span class="pre">Storable</span></code> 类型类的实例的任何数据类型。
这样重载分配运算符隐含的一点是分配的数据类型可以根据使用处类型信息推断出来！
基于我们对该数据使用的函数，Haskell 会知道要分配的内容。</p>
<p>例如，要分配一个指向 <code class="docutils literal notranslate"><span class="pre">CString</span></code> 的指针，会通过所调用函数将该指针会更新为指向特定的 <code class="docutils literal notranslate"><span class="pre">CString</span></code>，我们在下述伪代码中调用 <code class="docutils literal notranslate"><span class="pre">alloca</span></code>：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/DoBlock.hs</span>
<span class="nf">alloca</span> <span class="o">$</span> <span class="nf">\</span><span class="n">stringptr</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
   <span class="o">...</span> <span class="n">call</span> <span class="n">some</span> <span class="kt">Ptr</span> <span class="kt">CString</span> <span class="n">function</span>
   <span class="n">peek</span> <span class="n">stringptr</span>
</pre></div>
</div>
<p>[译注：伪代码，无对应文件]</p>
<p>这在局部分配一个 <code class="docutils literal notranslate"><span class="pre">Ptr</span> <span class="pre">CString</span></code>，并将代码块应用于该指针，然后该代码块调用 C 语言函数来修改该指针的内容。
最后，我们用 <code class="docutils literal notranslate"><span class="pre">Storable</span></code> 类的 <code class="docutils literal notranslate"><span class="pre">peek</span></code> 函数解引用该指针，产生一个 <code class="docutils literal notranslate"><span class="pre">CString</span></code>。</p>
<p>我们现在可以把它们放在一起，来完成我们的高级 PCRE 编译包装（high level PCRE compilation wrapper）。</p>
</div>
<div class="section" id="id9">
<h3>把这些全部放在一起<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>我们已经决定了用什么 Haskell 类型来表示 C 语言函数、结果数据表示形式以及如何管理它的内存。
我们已经为 <code class="docutils literal notranslate"><span class="pre">pcre_compile</span></code> 函数选择了标志的表示形式，并且确定了如何使 C 语言字符串与探查它的代码交互。
那么我们来编写一个完整的函数用来在 Haskell 中编译 PCRE 正则表达式吧：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/PCRE-compile.hs</span>
<span class="nf">compile</span> <span class="ow">::</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">PCREOption</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Regex</span>
<span class="nf">compile</span> <span class="n">str</span> <span class="n">flags</span> <span class="ow">=</span> <span class="n">unsafePerformIO</span> <span class="o">$</span>
  <span class="n">useAsCString</span> <span class="n">str</span> <span class="o">$</span> <span class="nf">\</span><span class="n">pattern</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">alloca</span> <span class="o">$</span> <span class="nf">\</span><span class="n">errptr</span>       <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">alloca</span> <span class="o">$</span> <span class="nf">\</span><span class="n">erroffset</span>    <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">pcre_ptr</span> <span class="ow">&lt;-</span> <span class="n">c_pcre_compile</span> <span class="n">pattern</span> <span class="p">(</span><span class="n">combineOptions</span> <span class="n">flags</span><span class="p">)</span> <span class="n">errptr</span> <span class="n">erroffset</span> <span class="n">nullPtr</span>
        <span class="kr">if</span> <span class="n">pcre_ptr</span> <span class="o">==</span> <span class="n">nullPtr</span>
            <span class="kr">then</span> <span class="kr">do</span>
                <span class="n">err</span> <span class="ow">&lt;-</span> <span class="n">peekCString</span> <span class="o">=&lt;&lt;</span> <span class="n">peek</span> <span class="n">errptr</span>
                <span class="n">return</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">err</span><span class="p">)</span>
            <span class="kr">else</span> <span class="kr">do</span>
                <span class="n">reg</span> <span class="ow">&lt;-</span> <span class="n">newForeignPtr</span> <span class="n">finalizerFree</span> <span class="n">pcre_ptr</span> <span class="c1">-- release with free()</span>
                <span class="n">return</span> <span class="p">(</span><span class="kt">Right</span> <span class="p">(</span><span class="kt">Regex</span> <span class="n">reg</span> <span class="n">str</span><span class="p">))</span>
</pre></div>
</div>
<p>仅此而已！
让我们仔细阅读这里的细节，因为它相当密集。
第一件突出的事情是使用 <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code>，这是一个非常声名狼藉的函数，具有非常不寻常的类型，从不吉利的 <code class="docutils literal notranslate"><span class="pre">System.IO.Unsafe</span></code> 导入：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/ForeignPtr.hs</span>
<span class="nf">unsafePerformIO</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>[译注：标准库定义，非本章代码，无对应文件]</p>
<p>这个函数有点奇怪：它接受一个 IO 值并将其转换成一个纯的值！
在长期以来对副作用危险性的警告后，我们这里刚好在一行中启用了危险效果。
非常不明智，这个函数使我们避开了 Haskell 类型系统提供的所有安全保证，将任意副作用插入到 Haskell 程序中的任何地方。
这样做的危险事关重大：我们可以打破优化、修改内存中的任意位置、删除用户机器上的文件、或者在我们的斐波那契序列中发射核导弹。
那么究竟为什么要有这个函数存在呢？</p>
<p>它正是为了使 Haskell 能够绑定到我们知道的引用透明、但不能证明给 Haskell 类型系统情况下的 C 语言代码。
它让我们对编译器说，“我知道我在做什么——这段代码真的是纯的”。
对于正则表达式编译，我们知道是这样的场景：给定相同的模式，我们应该每次都得到相同的正则表达式匹配器。
然而，证明这些给编译器超出了 Haskell 类型系统能力，所以我们被迫断言这个代码是纯的。
使用 <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> 正好让我们可以这样做。</p>
<p>但是，如果我们知道该 C 语言代码是纯的，那么为什么我们不正好这样声明——通过在导入声明中给它一个纯类型呢？
因为我们必须为 C 语言函数分配局部内存来用，这必须在 IO monad 中完成，因为这是一个局部的副作用。
不过这些副作用不会逃脱其外围的外部调用，所以包装的时候我们使用 <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> 来重新引入纯度。</p>
<p><code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> 的参数是我们编译函数的实际函数体，它由四部分组成：
将 Haskell 数据编排为 C 语言形式；
调用到 C 语言库中；
检查其返回值；
最后，从结果中构建 Haskell 值。</p>
<p>我们使用 <code class="docutils literal notranslate"><span class="pre">useAsCString</span></code> 和 <code class="docutils literal notranslate"><span class="pre">alloca</span></code> 编排、设置我们需要传给 C 语言的数据，然后使用之前开发的 <code class="docutils literal notranslate"><span class="pre">combineOptions</span></code> 将标志列表折叠成单个 <code class="docutils literal notranslate"><span class="pre">CInt</span></code>。
一旦一切就绪，我们就终于可以通过模式、标志以及指向结果的指针来调用 <code class="docutils literal notranslate"><span class="pre">c_pcre_compile</span></code> 了。
我们使用 <code class="docutils literal notranslate"><span class="pre">nullPtr</span></code> 作为字符编码表，它在本例中并未用到。</p>
<p>从 C 语言调用返回的结果是一个指向抽象 <code class="docutils literal notranslate"><span class="pre">PCRE</span></code> 结构的指针。
之后我们与 <code class="docutils literal notranslate"><span class="pre">nullPtr</span></code> 进行（比较）测试。
如果正则表达式出现问题，我们必须解引用错误指针，产生一个 <code class="docutils literal notranslate"><span class="pre">CString</span></code>。
然后我们使用库函数 <code class="docutils literal notranslate"><span class="pre">peekCString</span></code> 将其解压到一个正常的 Haskell 列表。
错误路径的最终结果是 <code class="docutils literal notranslate"><span class="pre">Left</span> <span class="pre">err</span></code> 的值，它向调用者表明失败。</p>
<p>而如果调用成功，我们就通过该 C 语言函数使用 <code class="docutils literal notranslate"><span class="pre">ForeignPtr</span></code> 分配一个新的存储托管的指针。
特殊值 <code class="docutils literal notranslate"><span class="pre">finalizerFree</span></code> 被绑定为这个数据的终结器，它使用标准的 C 语言的 <code class="docutils literal notranslate"><span class="pre">free</span></code> 来回收数据。
然后将其包装为不透明的 <code class="docutils literal notranslate"><span class="pre">Regex</span></code> 值。
成功的结果会标记为 <code class="docutils literal notranslate"><span class="pre">Right</span></code>，并返回给用户。
至此我们完工了。</p>
<p>我们需要使用 hsc2hs 处理我们的源文件，然后在 GHCi 中加载该函数。
然而，这样做导致第一次尝试时发生错误：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">hsc2hs</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">hsc</span>
<span class="o">$</span> <span class="n">ghci</span> <span class="kt">PCRE</span><span class="o">-</span><span class="n">compile</span><span class="o">.</span><span class="n">hs</span>

<span class="kt">During</span> <span class="n">interactive</span> <span class="n">linking</span><span class="p">,</span> <span class="kt">GHCi</span> <span class="n">couldn&#39;t</span> <span class="n">find</span> <span class="n">the</span> <span class="n">following</span> <span class="n">symbol</span><span class="kt">:</span>
  <span class="n">pcre_compile</span>
<span class="kt">This</span> <span class="n">may</span> <span class="n">be</span> <span class="n">due</span> <span class="n">to</span> <span class="n">you</span> <span class="n">not</span> <span class="n">asking</span> <span class="kt">GHCi</span> <span class="n">to</span> <span class="n">load</span> <span class="n">extra</span> <span class="n">object</span> <span class="n">files</span><span class="p">,</span>
<span class="nf">archives</span> <span class="n">or</span> <span class="kt">DLLs</span> <span class="n">needed</span> <span class="n">by</span> <span class="n">your</span> <span class="n">current</span> <span class="n">session</span><span class="o">.</span>  <span class="kt">Restart</span> <span class="kt">GHCi</span><span class="p">,</span> <span class="n">specifying</span>
<span class="nf">the</span> <span class="n">missing</span> <span class="n">library</span> <span class="n">using</span> <span class="n">the</span> <span class="o">-</span><span class="kt">L</span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">object</span><span class="o">/</span><span class="n">dir</span> <span class="n">and</span> <span class="o">-</span><span class="n">lmissinglibname</span>
<span class="nf">flags</span><span class="p">,</span> <span class="n">or</span> <span class="n">simply</span> <span class="n">by</span> <span class="n">naming</span> <span class="n">the</span> <span class="n">relevant</span> <span class="n">files</span> <span class="n">on</span> <span class="n">the</span> <span class="kt">GHCi</span> <span class="n">command</span> <span class="n">line</span><span class="o">.</span>
</pre></div>
</div>
<p>[译注：原文运行代码为 Regex.hs，根据实际情况改为 PCRE-compile.hs]</p>
<p>有点可怕。
当然，这只是因为我们没有将我们想要调用的 C 语言库链接到 Haskell 代码。
假设 PCRE 库已经安装在系统的默认库位置，我们可以通过在 GHCi 命令行中添加 <code class="docutils literal notranslate"><span class="pre">-lpcre</span></code> 来让 GHCi 知道它。
现在我们可以尝试一些正则表达式的代码，看看成功与错误的情况：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">ghci</span> <span class="kt">PCRE</span><span class="o">-</span><span class="n">compile</span><span class="o">.</span><span class="n">hs</span> <span class="o">-</span><span class="n">lpcre</span>
<span class="o">*</span><span class="kt">Regex</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span>
<span class="o">*</span><span class="kt">Regex</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span><span class="o">&gt;</span> <span class="n">compile</span> <span class="p">(</span><span class="n">pack</span> <span class="s">&quot;a.*b&quot;</span><span class="p">)</span> <span class="kt">[]</span>
<span class="kt">Right</span> <span class="p">(</span><span class="kt">Regex</span> <span class="mh">0x00000000028882a0</span> <span class="s">&quot;a.*b&quot;</span><span class="p">)</span>
<span class="o">*</span><span class="kt">Regex</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span><span class="o">&gt;</span> <span class="n">compile</span> <span class="p">(</span><span class="n">pack</span> <span class="s">&quot;a.*b[xy]+(foo?)&quot;</span><span class="p">)</span> <span class="kt">[]</span>
<span class="kt">Right</span> <span class="p">(</span><span class="kt">Regex</span> <span class="mh">0x0000000002888860</span> <span class="s">&quot;a.*b[xy]+(foo?)&quot;</span><span class="p">)</span>
<span class="o">*</span><span class="kt">Regex</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span><span class="o">&gt;</span> <span class="n">compile</span> <span class="p">(</span><span class="n">pack</span> <span class="s">&quot;*&quot;</span><span class="p">)</span> <span class="kt">[]</span>
<span class="kt">Left</span> <span class="s">&quot;nothing to repeat&quot;</span>
</pre></div>
</div>
<p>[译注：原文运行代码为 Regex.hs，根据实际情况改为 PCRE-compile.hs]</p>
<p>由 PCRE 库编译的正则表达式会打包成字节串且已编排到 C 语言。
然后其结果交回给 Haskell，其中使用默认的 <code class="docutils literal notranslate"><span class="pre">Show</span></code> 实例显示其结构。
我们的下一步是使用这些已编译的正则表达式来匹配某些字符串。</p>
</div>
</div>
<div class="section" id="id10">
<h2>匹配字符串<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>一个好的正则表达式库的第二部分是匹配函数。
给定一个已编译的正则表达式，该函数执行已编译正则表达式与某些输入的匹配，指示它是否匹配以及（如果是）匹配的字符串的哪些部分。
在 PCRE 中，这个函数是 <code class="docutils literal notranslate"><span class="pre">pcre_exec</span></code>，其类型为：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">int</span> <span class="n">pcre_exec</span><span class="p">(</span><span class="n">const</span> <span class="n">pcre</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span>
              <span class="n">const</span> <span class="n">pcre_extra</span> <span class="o">*</span><span class="n">extra</span><span class="p">,</span>
              <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">subject</span><span class="p">,</span>
              <span class="n">int</span> <span class="n">length</span><span class="p">,</span>
              <span class="n">int</span> <span class="n">startoffset</span><span class="p">,</span>
              <span class="n">int</span> <span class="n">options</span><span class="p">,</span>
              <span class="n">int</span> <span class="o">*</span><span class="n">ovector</span><span class="p">,</span>
              <span class="n">int</span> <span class="n">ovecsize</span><span class="p">);</span>
</pre></div>
</div>
<p>最重要的参数是从 <code class="docutils literal notranslate"><span class="pre">pcre_compile</span></code> 获取的 <code class="docutils literal notranslate"><span class="pre">pcre</span></code> 指针结构输入与主题（subject）字符串。
其他标志让我们提供簿记结构以及用于返回值的空间。
我们可以直接将此类型翻译为 Haskell 导入声明：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/RegexExec.hs</span>
<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">ccall</span> <span class="s">&quot;pcre.h pcre_exec&quot;</span>
    <span class="n">c_pcre_exec</span>     <span class="ow">::</span> <span class="kt">Ptr</span> <span class="kt">PCRE</span>
                    <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">PCREExtra</span>
                    <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">Word8</span>
                    <span class="ow">-&gt;</span> <span class="kt">CInt</span>
                    <span class="ow">-&gt;</span> <span class="kt">CInt</span>
                    <span class="ow">-&gt;</span> <span class="kt">PCREExecOption</span>
                    <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">CInt</span>
                    <span class="ow">-&gt;</span> <span class="kt">CInt</span>
                    <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">CInt</span>
</pre></div>
</div>
<p>我们使用与之前相同的方法为 <code class="docutils literal notranslate"><span class="pre">PCREExtra</span></code> 结构创建类型化的指针，并使用 <code class="docutils literal notranslate"><span class="pre">newtype</span></code> 来表示在正则表达式执行时传的标志。
这让我们能够确保用户不会错误地在正则表达式运行时传入编译期标志。</p>
<div class="section" id="id11">
<h3>提取关于模式的信息<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>调用 <code class="docutils literal notranslate"><span class="pre">pcre_exec</span></code> 涉及的主要的复杂因素是用于保存模式匹配器发现的匹配子串的偏移量的 <code class="docutils literal notranslate"><span class="pre">int</span></code> 指针数组。
这些偏移保存在偏移向量中，其所需大小通过分析输入正则表达式来确定它所包含的捕获模式的数量来确定的。
PCRE 提供了一个函数 <code class="docutils literal notranslate"><span class="pre">pcre_fullinfo</span></code> 用于确定关于正则表达式的很多信息，包括模式数量。
我们需要调用这个函数，并且现在，我们可以直接写下用于 <code class="docutils literal notranslate"><span class="pre">pcre_fullinfo</span></code> 绑定的 Haskell 类型为：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/RegexExec.hs</span>
<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">ccall</span> <span class="s">&quot;pcre.h pcre_fullinfo&quot;</span>
    <span class="n">c_pcre_fullinfo</span> <span class="ow">::</span> <span class="kt">Ptr</span> <span class="kt">PCRE</span>
                    <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">PCREExtra</span>
                    <span class="ow">-&gt;</span> <span class="kt">PCREInfo</span>
                    <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="n">a</span>
                    <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">CInt</span>
</pre></div>
</div>
<p>这个函数最重要的参数是已编译的正则表达式以及指示我们感兴趣的信息的 <code class="docutils literal notranslate"><span class="pre">PCREInfo</span></code> 标志。
在本例中，我们关心捕获的模式数。
这些标志以数字常量编码，我们特别地需要使用 <code class="docutils literal notranslate"><span class="pre">PCRE_INFO_CAPTURECOUNT</span></code> 值。
还有一系列其他用来确定该函数结果类型的常量，我们可以像之前一样使用 <code class="docutils literal notranslate"><span class="pre">#enum</span></code> 结构绑定。
最后一个参数是指向存储关于模式的信息（其大小取决于传入的标志参数！）的位置的指针。</p>
<p>调用 <code class="docutils literal notranslate"><span class="pre">pcre_fullinfo</span></code> 来确定捕获的模式数非常简单：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/RegexExec.hs</span>
<span class="nf">capturedCount</span> <span class="ow">::</span> <span class="kt">Ptr</span> <span class="kt">PCRE</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Int</span>
<span class="nf">capturedCount</span> <span class="n">regex_ptr</span> <span class="ow">=</span>
    <span class="n">alloca</span> <span class="o">$</span> <span class="nf">\</span><span class="n">n_ptr</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
         <span class="n">c_pcre_fullinfo</span> <span class="n">regex_ptr</span> <span class="n">nullPtr</span> <span class="n">info_capturecount</span> <span class="n">n_ptr</span>
         <span class="n">return</span> <span class="o">.</span> <span class="n">fromIntegral</span> <span class="o">=&lt;&lt;</span> <span class="n">peek</span> <span class="p">(</span><span class="n">n_ptr</span> <span class="ow">::</span> <span class="kt">Ptr</span> <span class="kt">CInt</span><span class="p">)</span>
</pre></div>
</div>
<p>这接受一个原始 PCRE 指针，并且为已匹配模式的 <code class="docutils literal notranslate"><span class="pre">CInt</span></code> 计数分配空间。
然后我们调用该信息函数，并查看其结果结构，找到一个 <code class="docutils literal notranslate"><span class="pre">CInt</span></code>。
最后，我们将它转换为一个普通的 Haskell <code class="docutils literal notranslate"><span class="pre">Int</span></code>，并将它传回给用户。</p>
</div>
<div class="section" id="id12">
<h3>与子串模式匹配<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>现在我们来写正则表达式匹配函数。
用于匹配（的函数）的 Haskell 类型与编译正则表达式类似：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/RegexExec.hs</span>
<span class="nf">match</span> <span class="ow">::</span> <span class="kt">Regex</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">PCREExecOption</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">ByteString</span><span class="p">]</span>
</pre></div>
</div>
<p>该函数是用户将字符串与已编译正则表达式匹配的方式。
再次重复，主要的设计点是它是一个纯函数。
匹配是一个纯函数：给定相同的输入正则表达式和主题字符串，它会始终返回相同的已匹配子串。
我们通过类型签名向用户传达这一信息，表明当你调用此函数时不会发生任何副作用。</p>
<p>其参数是一个已编译的 <code class="docutils literal notranslate"><span class="pre">Regex</span></code>、一个包含输入数据的严格 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 以及一个在运行时修改正则表达式引擎行为的标志列表。
其结果要么是 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> 值表明根本不匹配，要么刚好（just）是一个已匹配子串的列表。
我们使用 <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> 类型来清楚地指明匹配可能失败的类型。
通过对输入数据使用严格的 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code>，我们可以在无需复制的情况下提取已匹配子串，使接口效率更高。
如果在输入中匹配子串，则偏移向量会填充为成对的到主题字符串的整数偏移量。
我们需要循环遍历这个结果向量、读取偏移量、并在每次循环最后构建 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 切片。</p>
<p>匹配包装器的实现可以分为三个部分。
在顶层，我们的函数分解了已编译的 <code class="docutils literal notranslate"><span class="pre">Regex</span></code> 结构，产生了底层 <code class="docutils literal notranslate"><span class="pre">PCRE</span></code> 指针：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/RegexExec.hs</span>
<span class="nf">match</span> <span class="ow">::</span> <span class="kt">Regex</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">PCREExecOption</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">ByteString</span><span class="p">]</span>
<span class="nf">match</span> <span class="p">(</span><span class="kt">Regex</span> <span class="n">pcre_fp</span> <span class="kr">_</span><span class="p">)</span> <span class="n">subject</span> <span class="n">os</span> <span class="ow">=</span> <span class="n">unsafePerformIO</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="n">withForeignPtr</span> <span class="n">pcre_fp</span> <span class="o">$</span> <span class="nf">\</span><span class="n">pcre_ptr</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">n_capt</span> <span class="ow">&lt;-</span> <span class="n">capturedCount</span> <span class="n">pcre_ptr</span>

    <span class="kr">let</span> <span class="n">ovec_size</span> <span class="ow">=</span> <span class="p">(</span><span class="n">n_capt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="n">ovec_bytes</span> <span class="ow">=</span> <span class="n">ovec_size</span> <span class="o">*</span> <span class="n">sizeOf</span> <span class="p">(</span><span class="n">undefined</span> <span class="ow">::</span> <span class="kt">CInt</span><span class="p">)</span>
</pre></div>
</div>
<p>因为它是纯函数，我们可以使用 <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> 在内部隐藏任何内存分配副作用。
在对 <code class="docutils literal notranslate"><span class="pre">PCRE</span></code> 类型模式匹配之后，我们需要分解隐藏我们 C 语言所分配的原始 PCRE 数据的 <code class="docutils literal notranslate"><span class="pre">ForeignPtr</span></code>。
我们可以使用 <code class="docutils literal notranslate"><span class="pre">withForeignPtr</span></code>。
当进行调用时，这保持 Haskell 数据与 PCRE 值相关联，至少在它被此调用使用时防止它被收集。
然后我们调用该信息函数，并使其值来计算偏移向量的大小（该公式已在 PCRE 文档中给出）。
我们需要的字节数是元素的数量乘以一个 <code class="docutils literal notranslate"><span class="pre">CInt</span></code> 的大小。
为了可移植地计算 C 语言类型的大小，<code class="docutils literal notranslate"><span class="pre">Storable</span></code> 类提供了一个 <code class="docutils literal notranslate"><span class="pre">sizeOf</span></code> 函数，它接受所需类型的任意值（我们可以在这里使用 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 来进行类型分发）。</p>
<p>下一步是分配一个我们已计算大小的偏移向量，来将输入 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 转换为 C 语言 <code class="docutils literal notranslate"><span class="pre">char</span></code> 数组的指针。
最后，我们使用所有必需的参数来调用 <code class="docutils literal notranslate"><span class="pre">pcre_exec</span></code>：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/RegexExec.hs</span>
    <span class="n">allocaBytes</span> <span class="n">ovec_bytes</span> <span class="o">$</span> <span class="nf">\</span><span class="n">ovec</span> <span class="ow">-&gt;</span> <span class="kr">do</span>

        <span class="kr">let</span> <span class="p">(</span><span class="n">str_fp</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="ow">=</span> <span class="n">toForeignPtr</span> <span class="n">subject</span>
        <span class="n">withForeignPtr</span> <span class="n">str_fp</span> <span class="o">$</span> <span class="nf">\</span><span class="n">cstr</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="n">r</span> <span class="ow">&lt;-</span> <span class="n">c_pcre_exec</span>
                         <span class="n">pcre_ptr</span>
                         <span class="n">nullPtr</span>
                         <span class="p">(</span><span class="n">cstr</span> <span class="p">`</span><span class="n">plusPtr</span><span class="p">`</span> <span class="n">off</span><span class="p">)</span>
                         <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">len</span><span class="p">)</span>
                         <span class="mi">0</span>
                         <span class="p">(</span><span class="n">combineExecOptions</span> <span class="n">os</span><span class="p">)</span>
                         <span class="n">ovec</span>
                         <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">ovec_size</span><span class="p">)</span>
</pre></div>
</div>
<p>对于偏移向量，我们使用 <code class="docutils literal notranslate"><span class="pre">allocaBytes</span></code> 来精确地控制所分配数组的大小。
它就像 <code class="docutils literal notranslate"><span class="pre">alloca</span></code>，但不是使用 <code class="docutils literal notranslate"><span class="pre">Storable</span></code> 类来确定所需的大小，而是需要一个明确的大小（以字节为单位）来进行分配。
解开这些 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code>，产生指向它们所包含内存的底层指针，这可通过 <code class="docutils literal notranslate"><span class="pre">toForeignPtr</span></code> 完成，它会将我们友好的 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> 类型转换为托管的指针。
在结果上使用 <code class="docutils literal notranslate"><span class="pre">withForeignPtr</span></code> 给我们一个原始的 <code class="docutils literal notranslate"><span class="pre">Ptr</span> <span class="pre">CChar</span></code>，这正是我们需要传给 C 语言的输入字符串。
用 Haskell 编程通常只是解决类型谜题。</p>
<p>然后我们只是用原始 PCRE 指针、在正确偏移位置的输入字符串指针、它的长度以及结果向量指针来调用 <code class="docutils literal notranslate"><span class="pre">c_pcre_exec</span></code>。
返回一个状态码，并且最终分析该结果：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- file: ch17/RegexExec.hs</span>
            <span class="kr">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="kr">then</span> <span class="n">return</span> <span class="kt">Nothing</span>
                <span class="kr">else</span> <span class="kr">let</span> <span class="n">loop</span> <span class="n">n</span> <span class="n">o</span> <span class="n">acc</span> <span class="ow">=</span>
                            <span class="kr">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">r</span>
                              <span class="kr">then</span> <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="p">(</span><span class="n">reverse</span> <span class="n">acc</span><span class="p">))</span>
                              <span class="kr">else</span> <span class="kr">do</span>
                                    <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">peekElemOff</span> <span class="n">ovec</span> <span class="n">o</span>
                                    <span class="n">j</span> <span class="ow">&lt;-</span> <span class="n">peekElemOff</span> <span class="n">ovec</span> <span class="p">(</span><span class="n">o</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                    <span class="kr">let</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">substring</span> <span class="n">i</span> <span class="n">j</span> <span class="n">subject</span>
                                    <span class="n">loop</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">o</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span> <span class="kt">:</span> <span class="n">acc</span><span class="p">)</span>
                     <span class="kr">in</span> <span class="n">loop</span> <span class="mi">0</span> <span class="mi">0</span> <span class="kt">[]</span>

  <span class="kr">where</span>
    <span class="n">substring</span> <span class="ow">::</span> <span class="kt">CInt</span> <span class="ow">-&gt;</span> <span class="kt">CInt</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span>
    <span class="n">substring</span> <span class="n">x</span> <span class="n">y</span> <span class="kr">_</span> <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">empty</span>
    <span class="n">substring</span> <span class="n">a</span> <span class="n">b</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">end</span>
        <span class="kr">where</span>
            <span class="n">start</span> <span class="ow">=</span> <span class="n">unsafeDrop</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">a</span><span class="p">)</span> <span class="n">s</span>
            <span class="n">end</span>   <span class="ow">=</span> <span class="n">unsafeTake</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">))</span> <span class="n">start</span>
</pre></div>
</div>
<p>如果结果值小于零，那么出现了错误，或者未能匹配，所以我们将 <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> 返回给用户。
否则，我们需要一个循环从偏移向量中（通过 <code class="docutils literal notranslate"><span class="pre">peekElemOff</span></code>）取出成对的偏移量。
这些偏移量用于查找已匹配子串。
要构建子串，我们使用一个助手函数，给定一个起始与结束偏移量，丢弃主题字符串的外围部分，只产生匹配的部分。
循环一直运行，直到它提取够了我们告诉它的由匹配器发现的子串数量。</p>
<p>子串在一个尾递归循环中累积，建立了每个字符串的反向列表。
在返回该用户的子串之前，我们需要翻转该列表，并将其包装进一个成功的 <code class="docutils literal notranslate"><span class="pre">Just</span></code> 标签。
让我们试试吧！</p>
</div>
<div class="section" id="id13">
<h3>货真价实：编译并匹配正则表达式<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>如果我们采用这个函数、其外围的 hsc2hs 定义以及数据包装，并使用 hsc2hs 进行处理，我们可以将生成的 Haskell 文件加载到 GHCi 中并尝试我们的代码（我们需要导入 <code class="docutils literal notranslate"><span class="pre">Data.ByteString.Char8</span></code> 这样可以从字符串字面值来构建 <code class="docutils literal notranslate"><span class="pre">ByteString</span></code>）：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">hsc2hs</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">hsc</span>
<span class="o">$</span> <span class="n">ghci</span> <span class="kt">RegexExec</span><span class="o">.</span><span class="n">hs</span> <span class="o">-</span><span class="n">lpcre</span>
<span class="o">*</span><span class="kt">Regex</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">compile</span>
<span class="nf">compile</span> <span class="ow">::</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">PCREOption</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Regex</span>
<span class="o">*</span><span class="kt">Regex</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">match</span>
<span class="nf">match</span> <span class="ow">::</span> <span class="kt">Regex</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">ByteString</span><span class="p">]</span>
</pre></div>
</div>
<p>[译注：原文运行代码为 Regex.hs，根据实际情况改为 RegexExec.hs]</p>
<p>事情看起来合情合理。
现在我们来尝试一些编译与匹配。
首先，来点容易的：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="kt">Regex</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span>
<span class="o">*</span><span class="kt">Regex</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="kt">Right</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">compile</span> <span class="p">(</span><span class="n">pack</span> <span class="s">&quot;the quick brown fox&quot;</span><span class="p">)</span> <span class="kt">[]</span>
<span class="o">*</span><span class="kt">Regex</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span><span class="o">&gt;</span> <span class="n">match</span> <span class="n">r</span> <span class="p">(</span><span class="n">pack</span> <span class="s">&quot;the quick brown fox&quot;</span><span class="p">)</span> <span class="kt">[]</span>
<span class="kt">Just</span> <span class="p">[</span><span class="s">&quot;the quick brown fox&quot;</span><span class="p">]</span>
<span class="o">*</span><span class="kt">Regex</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span><span class="o">&gt;</span> <span class="n">match</span> <span class="n">r</span> <span class="p">(</span><span class="n">pack</span> <span class="s">&quot;The Quick Brown Fox&quot;</span><span class="p">)</span> <span class="kt">[]</span>
<span class="kt">Nothing</span>
<span class="o">*</span><span class="kt">Regex</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span><span class="o">&gt;</span> <span class="n">match</span> <span class="n">r</span> <span class="p">(</span><span class="n">pack</span> <span class="s">&quot;What do you know about the quick brown fox?&quot;</span><span class="p">)</span> <span class="kt">[]</span>
<span class="kt">Just</span> <span class="p">[</span><span class="s">&quot;the quick brown fox&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>（我们也可以使用 <code class="docutils literal notranslate"><span class="pre">OverloadedStrings</span></code> 扩展来避免 <code class="docutils literal notranslate"><span class="pre">pack</span></code> 调用）。
或者我们可以更冒险一些：</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="kt">Regex</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="kt">Right</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">compile</span> <span class="p">(</span><span class="n">pack</span> <span class="s">&quot;a*abc?xyz+pqr{3}ab{2,}xy{4,5}pq{0,6}AB{0,}zz&quot;</span><span class="p">)</span> <span class="kt">[]</span>
<span class="o">*</span><span class="kt">Regex</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span><span class="o">&gt;</span> <span class="n">match</span> <span class="n">r</span> <span class="p">(</span><span class="n">pack</span> <span class="s">&quot;abxyzpqrrrabbxyyyypqAzz&quot;</span><span class="p">)</span> <span class="kt">[]</span>
<span class="kt">Just</span> <span class="p">[</span><span class="s">&quot;abxyzpqrrrabbxyyyypqAzz&quot;</span><span class="p">]</span>
<span class="o">*</span><span class="kt">Regex</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="kt">Right</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">compile</span> <span class="p">(</span><span class="n">pack</span> <span class="s">&quot;^([^!]+)!(.+)=apquxz</span><span class="se">\\</span><span class="s">.ixr</span><span class="se">\\</span><span class="s">.zzz</span><span class="se">\\</span><span class="s">.ac</span><span class="se">\\</span><span class="s">.uk$&quot;</span><span class="p">)</span> <span class="kt">[]</span>
<span class="o">*</span><span class="kt">Regex</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Char8</span><span class="o">&gt;</span> <span class="n">match</span> <span class="n">r</span> <span class="p">(</span><span class="n">pack</span> <span class="s">&quot;abc!pqr=apquxz.ixr.zzz.ac.uk&quot;</span><span class="p">)</span> <span class="kt">[]</span>
<span class="kt">Just</span> <span class="p">[</span><span class="s">&quot;abc!pqr=apquxz.ixr.zzz.ac.uk&quot;</span><span class="p">,</span><span class="s">&quot;abc&quot;</span><span class="p">,</span><span class="s">&quot;pqr&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>真的太棒了。
Perl 正则表达式的全部强大功能，尽在你指尖下的 Haskell 代码中。</p>
<p>在本章中，我们研究了如何声明让 Haskell 代码调用 C 语言函数的绑定、如何编排两种语言之间的不同数据类型、如何分配低级别内存（通过局部分配或者通过 C 语言内存管理）以及如何利用 Haskell 类型系统和垃圾收集器来自动化处理 C 语言的大量工作。
最后，我们研究了 FFI 预处理器如何缓解构建新绑定的大量工作。
其结果是一个实际上主要由 C 语言实现的自然的 Haskell API。</p>
<p>大多数 FFI 任务可归类为上述类别。
我们无法涵盖的其他高级技术包括：将 Haskell 链接到 C 语言程序、将回调从一种语言注册到另一种语言以及 <code class="docutils literal notranslate"><span class="pre">c2hs</span></code> 预处理工具。
关于这些主题的更多信息可以在线查到。</p>
</div>
</div>
</div>


        <!--<div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'realworldhaskll'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>-->
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="16.html">第 16 章：使用Parsec</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="18.html">第 18 章： Monad变换器</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, huangz1990.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>